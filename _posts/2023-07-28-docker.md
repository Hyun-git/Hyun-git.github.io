---
title: Docker란?
layout: post
---

# Docker
Go 언어로 작성된 **컨테이너 기반** 오픈소스 가상화 플랫폼이다. 

### 가상화의 이유
*  할당된 CPU에 비해 사용량이 낮으면 리소스 낭비 -> 하지만 한 서버에 모든 서비스를 올리면 문제가 되는 상황을 해결하기 위해 나온 것이 서버의 가상화
*  VM이 대표적이고 VM은 OS가상화 이다.



## 컨테이너
가상화의 기술중 하나로 대표적으로 LXC(LInux Container)가 있다. 기존 OS를 가상화 시키는 것이 아닌 OS레벨의 가상화로 프로세스를 격리시켜 동작하는 방식
![]({{ 'VM.png' | relative_url }})
VM은 HOST OS 위에 Hypervisor 엔진 그리고 그 위에 Guest OS를 올려 사용합니다. → 이는 가상화된 하드웨어 위에 OS가 올라가는 형태 → HOST와 분리 이게 장점일 수 있지만 OS 위에 다른 OS를 올리기 때문에 무겁고 느림

컨테이너는 엔진 위에 Apllication의 실행에 필요한 바이너리만 올라감 → 엔진위에서 바로 동작하고 host커널을 공유함 → 커널을 공유하면 io 처리가 쉽게 되서 성능의 효율을 높일 수 있음 → 즉 컨테이너는 가상  머신을 생성하는 것이 아니라 HostOS 가 사용하는 자원을 분리해서 여러 환경을 만들 수 있도록 하는 것

OS 가상화는 보안적 측면, 멀티 OS가 가능하다. 이와 반대로 컨테이너는 멀티 OS가 안됨. 그럼에도 쓰는 이유는 성능향상, 뛰어난 이식성, 쉽게 scale out할 수 있는 유연성이라고 생각

## DockerImage
DockerImage란 컨테이너를 실행할 수 있는 실행파일, 설정 값 들을 가지고 있는 것 → 그림과 같이 이미지를 담고 실행 시키면 해당 프로세스가 동작
![]({{ 'dockerImage.png' | relative_url }})

### Docker File

Docker image들은 Docker Hub에서 잘 활성화 되어있다. 이미 여러 회사들은 소프트웨어를 Docker Hub를 통해 배포하고 Docker hub에서 image를 pull 해서  간단하게 컨테이너에 넣어 사용 할 수 있다. → 하지만 배포판이 없거나 배포판에서 뭔가를 더 더하고 싶다면? 이때 사용하는게 Docker File이다. 

Docker File은 이미지 생성 출발점으로 이미지를 구성하기 위한 명령어들을 작성하여 이미지를 구성할 수 있다. 즉 Docker File만 읽을 수 있다면 해당 이미지가 어떻게 구성되어 있는지도 알 수있습니다!          

```jsx
$vim DockerFile

FROM ubuntu:14.04 => 기반이 되는 이미지 레이어 <이미지이름>:<태그> 형식으로 작성

#app 디렉토리 생성
RUN mkdir -p /app => 도커이미지가 생성되기 전에 수행할 쉘 명령어

#Docker 이미지 내부에서 RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉토리를 설정함
WORKDIR /app => CMD에서 설정한 실행 파일이 실행될 디렉토리

#현재 디렉토리에 있는 파일들을 이미지 내부 /app 디렉토리에 추가
ADD ./app

RUN apt-gget update
RUN apt-get install apache2
RUN service apache2 start

VOLUME ["/data", "/var/log/httpd"] => 디렉토리의 내용을 컨테이너에 저장하지 않고 호스트에 저장하도록 설정 데이터 볼륨을 호스트의 특정 디렉토리와 연결하려면 docker run 에서 -v 옵션을 사용해야함

#포트를 외부로 노출
EXPOSE 80 => 호스트와 연결할 포트 번호

#쉘을 사용하지 않고 컨테이너가 시작되었을 때 logbackup 스크립트를 실행
CMD["/app/log.backup.sh"] => 컨테이너가 시작됐을 때 실행할 실행 파일 또는 셀 스크립트 -> 도커 파일에서 한번만 쓸 수 있음

:wq!
```

.dockerIgnore ⇒ Docker 이미지 생성 시 이미지 안에 들어가지 않을 파일을 지정 가능

dockeFile 경로에서  아래 명령어를 입력하면 이미지가 생성됨

```jsx
$docker build -t [만들 이미지 이름]
```

이미지는 **컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것**
으로 상태값을 가지지 않고 변하지 않습니다(Immutable). 컨테이너는 이미지를 실행한 상태라고 볼 수 있고 추가되거나 변하는 값은 컨테이너에 저장됩니다. 같은 이미지에서 여러개의 컨테이너를 생성할 수 있고 컨테이너의 상태가 바뀌거나 컨테이너가 삭제되더라도 이미지는 변하지 않고 그대로 남아있습니다.

말그대로 이미지는 컨테이너를 실행하기 위한 모오오오오든 정보를 가지고 있기 때문에 더 이상 의존성 파일을 컴파일하고 이것저것 설치할 필요가 없습니다. 이제 새로운 서버가 추가되면 미리 만들어 놓은 이미지를 다운받고 컨테이너를 생성만 하면 됩니다. 한 서버에 여러개의 컨테이너를 실행할 수 있고, 수십, 수백, 수천대의 서버도 문제없습니다.

### 핫한 이유

완전히 새로운 기술이 아니라 이미 존재하는 기술을 잘 포장했다고 볼 수 있음

### 레이어 저장 방식

도커 이미지는 컨테이너 실행을 위한 모든 정보를 가지고 있기에 용량이 수백메가에 이름, 처음 이미지를 다운 받을 때는 크게 부담이 되지 않지만 기존 이미지에 파일 하나 추가한다고 수백메가를 다시 다운 받는 건 매우 비효율

도커는 여기서 레이어라는 개념을 사용하고 유니온 파일 시스템을 이용해서 여러개의 레이어를 하나의 파일 시스템으로 사용 할 수 있게 해줌 이미지는 여러개의 읽기 전용 레이어로 구성되고 파일이 추가 되고 수정되면 새로운 레이어가 생성됨 

컨테이너 생성시에도 레이어 방식을 이용하는데 기존의 이미지 레이어 위에 읽기/쓰기 레이어를 추가함 이미지 레이어를 그대로 사용하면서 컨테이너가 실행중에 생성하는 파일이나 변경된 내용은 읽기/쓰기 레이어에 저장되므로여러개의 컨테이너를 생성해도 최소한의 용량만 사용함

![]({{ 'dockercommand.png' | relative_url }})


[참조1](https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90)

[참조2](https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html)
